---
layout: post
title: 1-2. Introduction to Operating Systems
subtitle: OS Study Week1-2
categories: OS
tags: OS
sidebar: []
---



반효경 교수님의 [2014-1 운영체제 강의](http://www.kocw.net/home/search/kemView.do?kemId=1046323)를 듣고 정리한 글입니다.

<br>

### 운영체제

좁은 의미의 운영체제[**커널**]:  운영체제의 핵심적인 부분. 컴퓨터의 전원을 켜고 부팅이 된 이후에 항상 메모리에 상주함 (전공자의 입장에서 운영체제는 이 부분!)

넓은 의미의 운영체제: 커널을 포함하며, 각종 주변 시스템을 다루는 유틸리티를 포함 (ex: 윈도우)

<br>

### 운영체제의 목적

컴퓨터 시스템의 **자원을 효율적으로 관리**

- 자원: CPU, 메모리, 각종 입출력 장치 등의 하드웨어 자원 & 프로세스, 파일 메시지 등의 소프트웨어 자원
- 이미 주어진 자원으로 최대한의 성능을 뽑아내는 것이 목적 → 자원을 **효율적** + 형평적으로 분배함
- 사용자 및 운영체제 자신을 보호해야 함

<br>

컴퓨터 시스템을 편리하게 사용할 수 있게 함

- 여러 프로그램이 하나의 컴퓨터에서 실행될 때, 자신의 프로그램만이 해당 컴퓨터에서 실행되는 것과 같은 느낌을 주는 것이 운영체제의 목적
- ex) 실제로는 여러 프로그램이 CPU를 빠른 시간 내에 나눠서 사용하는 것이지만 사용자가 보기에 한 프로그램만이 온전히 실행되고 있다고 느낄 수 있음

<br>

### 운영체제의 분류

동시 작업 가능 여부에 따라

- 단일 작업(주로 과거의 OS) - 한 번에 하나의 작업만 처리 (ex: MS-DOS)
- 다중 작업(최근의 OS) - 동시에 두 개 이상의 작업 처리 (ex: UNIX, MS Windows)

<br>

지원해주는 사용자의 수에 따라

- 단일 사용자 (ex: MS-DOS, MS Windows)
- 다중 사용자 (ex: UNIX, NT server)

<br>

처리 방식에 따라

- 일괄 처리(batch processing) - 어떤 작업이 주어져있을 때 바로바로 처리하는 것이 아니라, 작업을 모아서 한꺼번에 처리함 (현대 OS에서는 해당 처리 방식을 찾아보기 어려움) → interactive하지 않음
- **시분할(time sharing)** - 여러 작업이 실행 될 때, 프로그램은 동시에 실행되는 것처럼 보이지만 운영체제가 작은 시간 단위로 나누어서 프로그램마다 시간을 할당함 (현대의 OS에서 사용하는 방식) → interactive한 방식, 일괄 처리 시스템에 비해 짧은 응답 시간 *BUT*, 시간의 제약조건이 없어서 사용자가 폭발적으로 증가하면 응답 시간이 늦어질 수 있음
- 실시간(realtime OS) - 정해진 시간 안에 어떤 일이 반드시 종료됨을 보장함 (정확한 시간을 맞춰야 하는 정교한 장비에 주로 사용)
  - 특수 시스템에 사용됨: 원자로 및 공장 제어, 미사일 제어, 반도체 장비, 로보트 제어 등
  - 확장: Hard realtime system(시간 제약이 치명적임 - ex: 미사일 제어), Soft realtime system(시간 제약이 비교적 덜 치명적임 - ex: 영화)

*범용 운영체제(시분할)에서 요구되는 실시간성에 대한 처리도 필요함 (ex: 스마트폰으로 영화를 보거나 내비게이션을 이용하는 것)

<br>

```
Multitasking: 여러 작업이 동시에 시행되는 것
Multiprogramming: 여러 프로그램이 메모리에 동시에 올라가있는 것 (multitasking이 되려면 multiprogramming을 당연히 만족해야함)
Time sharing: CPU를 강조한 것
Multiprocess: 여러 프로그램이 동시에 실행됨
→ 유사한 용어

*Multiprocesser:  하나의 컴퓨터에 여러 CPU가 붙어있는 것(하드웨어적으로 다름)
```

<br>

### 운영체제의 예

유닉스(UNIX) 계열

- 유닉스는 대형 컴퓨터를 위해 만들어진 운영체제
- Multitasking이 되고 여러 사용자를 동시에 지원해줌
- C언어로 대부분 작성됨
- 초창기에는 소스코드가 공개됨 → 학습하기에도 좋음
- 높은 이식성 → 다른 컴퓨터에 이식하기가 쉬움
- 커널의 크기가 작음
- 확장성이 좋음
- 초창기에는 무료로 공개되었었음
- 다양한 버전: System V, FreeBSD, SunOS, Solaris, Linux(→ 리눅스는 공개 소프트웨어!, 개인 PC에도 사용하기 용이함, 안드로이드의 커널로도 사용됨)

<br>

DOS

- 개인용 컴퓨터 PC를 위해 만들어진 운영체제
- 단일 사용자, 단일 작업용 운영체제로 출발함 (메모리 관리 능력의 한계 - 주 기억 장치 640KB)

Windows로 발전

- MS사의 다중 작업용 GUI 기반 운영 체제
- Plug and Play, 네트워크 환경 강화
- DOS용 응용 프로그램과 호환성 제공
- 초창기에는 불안정성 존재. 현재는 많이 해소됨
- 풍부한 지원 소프트웨어

*스마트 디바이스를 위한 운영체제 iOS 등도 등장하면서 운영체제가 점점 여러가지 형태로 발전함

<br>

### 운영체제의 구조

![image](https://user-images.githubusercontent.com/71377968/200158656-3f24acb1-5fca-49f3-8e50-4db8fe591eac.png)

- CPU를 누구한테 줄 것인가 - **CPU 스케줄링**
- 한정된 메모리를 어떻게 쪼개어 쓸 것인가 - **메모리 관리**
- 디스크에 파일을 어떻게 보관할 것인가 - **파일 관리**
- 각기 다른 입출력장치와 컴퓨터 간에 어떻게 정보를 주고 받게 할 것인가 - **입출력 관리**
- 프로그램들을 어떻게 관리하고, 자원 할당 및 반환은 어떻게 할 것이며, 프로세스의 생성과 삭제, 그리고 프로세스 간 협력은 어떻게 할 것인가 - **프로세스 관리**
- 그 외) 보호 시스템, 네트워킹, 명령어해석기(command line interpreter)

*CPU 스케줄링과 디스크 스케줄링은 다른 측면이 있음 (CPU의 경우 너무 빠르기 때문에 이것을 어떻게 관리해야 하나, 디스크의 경우 헤드의 움직임을 적게 하면서 많은 요청을 빨리 처리할 수 있는가)

*I/O 디바이스는 CPU에 비해 매우 느림 (인터럽트 사용)
