<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="/jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="/jekyll-theme-yat/" rel="alternate" type="text/html" /><updated>2023-01-04T22:53:26+00:00</updated><id>/jekyll-theme-yat/feed.xml</id><title type="html">Jingnii Develop</title><subtitle>I am studying... Algorithm, Flask, Flutter, Spring Boot, CV, NLP...</subtitle><author><name>kji-dec</name></author><entry><title type="html">DPA 2일차</title><link href="/jekyll-theme-yat/dpa/2023/01/04/DPA-day2.html" rel="alternate" type="text/html" title="DPA 2일차" /><published>2023-01-04T00:00:00+00:00</published><updated>2023-01-04T00:00:00+00:00</updated><id>/jekyll-theme-yat/dpa/2023/01/04/DPA%20day2</id><content type="html" xml:base="/jekyll-theme-yat/dpa/2023/01/04/DPA-day2.html"><![CDATA[<h2 id="github">GitHub</h2>

<aside> ❗ **git ≠ github**

</aside>

<p>git은 버전 관리 시스템(VCS), github는 git을 사용해 cloud에 저장하는 서비스! github과 같은 레벨에는 gitlab(사설 서버 구성 가능), bitbucket이 있음</p>

<p>git client에는 gitCLI, git GUI, sourcetree, kraken, smartGit 등이 있고, 나는 fork랑 gitCLI, kraken을 사용해봤는데 fork가 가장 깔끔했으나, gui가 어색해서 gitCLI로 돌아옴</p>

<p><br /></p>

<p>git의 특징</p>

<ul>
  <li>빠른 속도, 단순한 구조</li>
  <li>분산형 저장소 지원</li>
  <li>비선형적 개발 가능 (브랜치 이용)</li>
</ul>

<p><br /></p>

<p>git 이용의 장점</p>

<ul>
  <li>동시 작업 가능</li>
  <li>commit 단위로 수정 내용 관리, 배포 뿐 아니라 원하는 시점으로 checkout 가능!</li>
  <li>새 기능 추가 시에는 branch 이용, test 완료 후에는 merge 가능</li>
  <li>인터넷이 연결되지 않아도 개발 가능</li>
</ul>

<p><br /></p>

<p>git object</p>

<ul>
  <li>
    <p>Blob: 파일 하나의 내용에 대한 정보</p>
  </li>
  <li>
    <p>Tree: Blob이나 subtree의 메타 데이터(디렉토리 위치, 속성, 이름 등)</p>
  </li>
  <li>
    <p>Commit: 커밋 순간의 snapshot</p>

    <p><br /></p>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/71377968/210664185-cc9beb90-7542-4588-9f1f-caf6d43efb15.png" alt="image" /></p>

<p><strong>conventional commits</strong></p>

<ol>
  <li>commit의 제목은 commit을 설명하는 하나의 구나 절로 완성</li>
  <li>capitalize 활용</li>
  <li>prefix 꼭 달기!
    <ul>
      <li>feat: 기능 개발 관련</li>
      <li>refactor: 수정</li>
      <li>fix: 오류 개선 및 버그 패치</li>
      <li>docs: 문서화 작업</li>
      <li>test: test 관련</li>
      <li>conf: 환경설정 관련</li>
      <li>build: 빌드 관련</li>
      <li>ci: Continuous Integration 관련</li>
    </ul>
  </li>
</ol>

<p>+) 특정 버전의 api 지원을 중단하는 등의 강조해야하는 커밋이 있는 경우에는 BREAKING CHANGE 프리픽스를 이용하기도 함</p>

<ul>
  <li>commit 시에는 <strong>동작 가능한</strong> 최소 단위로 자주 할 것</li>
  <li>해당 작업단위에 수행된 모든 파일 변화가 해당 commit에 포함되어야 함</li>
  <li>모두가 이해할 수 있는 log 작성</li>
</ul>

<p><br /></p>

<p>LICENSE</p>

<ul>
  <li>MIT License: MIT에서 만든 라이센스로, 모든 행동에 제약이 없으며, 저작권자는 소프트웨어와 관련한 책임에서 자유로움(완전한 오픈소스!!)</li>
  <li>Apache License 2.0: Apache 재단이 만든 라이센스로, 특허권 관련 내용이 포함되어 있음</li>
  <li>GNU General Public License v3.0: 가장 많이 알려져 있으며, 의무사항 존재</li>
</ul>

<p><br />.gitignore 파일을 이용해 특정 파일 혹은 디렉토리를 추적하지 않게 할 수 있음</p>

<p>.gitattributes를 이용해 파일 단위, 디렉토리 단위로 다른 설정을 부여할 수 있음</p>

<p><br />파일 rename 시에, github에 바로 push를 하게 되면 deleted되고, 새로운 파일이 생성되었다고 로그가 남기 때문에 <code class="language-plaintext highlighter-rouge">git mv [이전 파일] [새로운 파일]</code>로 이름을 변경해야함!</p>

<p><br />commit을 잘못했을 경우</p>

<p>*reset보다는 revert를 이용하기!</p>

<p>revert에서 <code class="language-plaintext highlighter-rouge">--no-commit</code> 옵션의 경우, 매 revert마다 commit 메시지를 작성하는 게 아니라 revert가 전부 끝나면 한번에 commit할 수 있음</p>

<p><br /><strong>CI</strong></p>

<ul>
  <li>자동화된 프로세스(빌드, 테스트, 머지)</li>
  <li>코드 변경사항의 정기적 빌드, 테스트 병합 자동화</li>
  <li>장점
    <ul>
      <li>빠른 디버깅</li>
      <li>코드 품질 개선</li>
      <li>검증 및 릴리즈 시간 단축</li>
    </ul>
  </li>
</ul>

<p><br /><strong>CD</strong></p>

<ul>
  <li>Continuous Delivery: 공유 저장소로 자동 Release(Test → Staging)</li>
  <li>Continuous Delivery: Production Level까지 자동 Deploy(Test→Staging→Production)</li>
  <li>MSA + Agile일 경우, 사용자에게 최대한 빠른 시간 안에 Production 제공 필요</li>
</ul>

<p><br />깃헙의 CI/CD = GitHub Actions</p>

<p>→ 개발 workflow를 자동으로 관리</p>

<p>Workflow</p>

<ul>
  <li>Job들로 구성된 최상위 개념</li>
  <li>event에 의해 자동 트리거</li>
  <li>YAML파일로 작성, 레포의 .github/workflows에 저장</li>
</ul>

<p>Event</p>

<ul>
  <li>Workflow를 실행하는 규칙 (workflow 동작의 조건)</li>
  <li>push, pull request, cron, webhook으로 연결된 외부 이벤트에 의해 실행</li>
</ul>

<p>Job</p>

<ul>
  <li>Step들로 구성</li>
  <li>가상환경의 인스턴스에서 실행</li>
  <li>다른 Job에 의존 관계를 가질 수 있고, 독립 병렬 실행도 가능함!</li>
</ul>

<p>Step</p>

<ul>
  <li>Task들의 집합으로 커맨드를 실행하거나 action을 실행</li>
</ul>

<p>Action</p>

<ul>
  <li>가장 작은 단위</li>
  <li>Step을 연결해서 Job을 구성함</li>
  <li>재사용 가능</li>
  <li>marketplace나 개인이 만든 action을 사용할 수 있음</li>
</ul>

<p>Runner</p>

<ul>
  <li>workflow가 실행될 인스턴스</li>
  <li>github-hosted runner와 self-hosted runner로 나뉨</li>
</ul>

<p><br /><strong>Branching</strong></p>

<ul>
  <li>git flow
    <ul>
      <li>(hotfix)-master-(release)-develop-feature</li>
      <li>:-) 가장 많이 사용함, 각 단계가 명확히 구분됨</li>
      <li>:-( 복잡</li>
      <li>gitflow init 명령으로 시작</li>
    </ul>
  </li>
  <li>github flow
    <ul>
      <li>master - feature</li>
      <li>:-) 브랜치 모델 단순화, master의 모든 커밋은 deployable</li>
      <li>:-( CI의존성이 높음, 실수한 코드도 바로 배포됨 (PR 이용으로 완화!)</li>
    </ul>
  </li>
  <li>gitlab flow
    <ul>
      <li>production(위 방식의 master 역할) - pre-production(test server) - master - feature</li>
      <li>:-) deploy, issue에 대한 대응이 가능하도록 보완</li>
      <li>:-( git flow와 반대됨</li>
    </ul>
  </li>
</ul>

<p><br />issue에 들어가는 내용: 설명, 할 일, 참조</p>

<p><br />느낀점</p>

<p>그동안 깃헙으로 협업을 해올 때 issue template같은 부분을 정확히 지키지 못했는데 이번 경험을 통해 컨벤션을 좀 더 정확히 정하고 실제 프로젝트에 반영해야겠다고 생각함</p>

<p><br /><strong>REF</strong></p>

<p>DPA 2일차 오전 강의</p>

<p>https://velog.io/@lucasonestar/Git-work-flow-Fundamental-Command</p>

<p><br /></p>

<p><br /></p>

<h2 id="jira--confluence">Jira &amp; Confluence</h2>

<h2 id="jira">Jira</h2>

<ul>
  <li>흩어진 업무들 한 눈에 정리</li>
  <li>장기적으로 봤을 때 좋은 전략을 수립할 수 있음</li>
</ul>

<p><br /><strong>프로젝트</strong></p>

<p>팀 단위의 업무 혹은 팀 내의 큰 단위의 업무를 프로젝트로 묶어서 관리함</p>

<p>→ 단위가 많음</p>

<p><br /><strong>이슈</strong></p>

<p>업무의 작은 단위로, 처리해야 하는 업무를 의미함</p>

<p>jira 내에서 중요한 정보는 누가 담당할 것인지(담당자), 언제 시작하고 마감 기한이 언제인지, 현재 진행 상태가 무엇인지 알아야 이슈 발행 가능</p>

<p><br /><strong>워크플로</strong></p>

<p>업무의 상태를 변경하고 조절할 수 있음. 워크플로는 거의 고정되어서 사용됨.</p>

<p><br /><strong>기타 Jira 특징</strong></p>

<ul>
  <li>git service에서 소스 연동을 하면 jira issue id를 가지고 소스 tracking이 가능함</li>
  <li>webhook을 이용해 슬랙으로 알림을 줄 수 있음</li>
  <li>스프린트 → 특정 기간을 잡아 점검하고 뭐하고를 반복함</li>
  <li>필터링 기능: 원하는 필터에 따라 사용자 정의 필터링이 가능함(<em>JQL</em> 사용)</li>
</ul>

<h3 id="confluence"><br />Confluence</h3>

<p>: 노션, wiki와 같이 공동 작업이 가능한 보드</p>

<p>confluence는 jira와 연동이 가능하기 때문에 이슈 관리 및 자세한 정보 관리 시에 용이함</p>

<p><br /><strong>REF</strong></p>

<p>DPA 오후 강의</p>]]></content><author><name>kji-dec</name></author><category term="DPA" /><summary type="html"><![CDATA[GitHub]]></summary></entry><entry><title type="html">5-2. CPU Scheduling 2</title><link href="/jekyll-theme-yat/os/2022/11/30/OS-Study-Week5-2.html" rel="alternate" type="text/html" title="5-2. CPU Scheduling 2" /><published>2022-11-30T00:00:00+00:00</published><updated>2022-11-30T00:00:00+00:00</updated><id>/jekyll-theme-yat/os/2022/11/30/OS%20Study%20Week5-2</id><content type="html" xml:base="/jekyll-theme-yat/os/2022/11/30/OS-Study-Week5-2.html"><![CDATA[<p>반효경 교수님의 <a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">2014-1 운영체제 강의</a>를 듣고 정리한 글입니다.</p>

<p><br /></p>

<h3 id="multilevel-queue">Multilevel Queue</h3>

<p><img src="https://user-images.githubusercontent.com/71377968/204631070-a00b53c7-425e-4e5f-9e23-931ac59c061f.png" alt="image" /></p>

<ul>
  <li>위로 갈수록 우선순위가 높음</li>
  <li>고려 사항
    <ul>
      <li>프로세스를 어느 줄에 넣을 것인가</li>
      <li>우선순위가 높은 큐가 비어있지 않으면 계속 우선순위가 높은 큐가 CPU를 가지고 있고 다른 큐로는 넘기지 않을 것인가 ← 우선 순위가 낮은 큐는 starvation</li>
    </ul>
  </li>
  <li>ready queue를 여러개로 분할 (여러 줄로 CPU를 기다리는 것)
    <ul>
      <li>foreground(interactive) ← RR(사람과 상호작용을 해야하므로 짧은 시간 여러번 도는 게 나음)</li>
      <li>background(batch - CPU만 오래 잡고 있는 job) ← FCFS(어차피 response가 빨라야 하는 것도 아니니 context overhead를 줄이는 게 나음)</li>
    </ul>
  </li>
  <li>큐에 대한 스케줄링 필요
    <ul>
      <li>Fixed priority scheduling: 우선순위가 높은 큐가 비어있을 때만 낮은 큐가 기회를 얻는 방식 → starvation</li>
      <li>Time slice: 각 큐에 CPU time을 적절한 비율로 할당</li>
    </ul>
  </li>
  <li>차별적인 방안이지만, 우선 순위가 높은 프로세스가 더 빨리 CPU를 얻어야 하므로 이런 방법을 사용함</li>
  <li>그러나, 우선순위에 변동이 없다는 것은 문제가 있음 → multilevel feedback queue</li>
</ul>

<p><br /></p>

<h3 id="multilevel-feedback-queue">Multilevel Feedback Queue</h3>

<p><img src="https://user-images.githubusercontent.com/71377968/204631655-480bff64-53de-4531-b05f-8c3e55b243ed.png" alt="image" /></p>

<ul>
  <li>프로세스가 다른 ready queue로 갈 수 있음</li>
  <li>고려 사항
    <ul>
      <li>queue를 몇 개를 둘 건지</li>
      <li>큐 내의 스케줄링 알고리즘을 어떤걸로 사용할 것인가</li>
      <li>우선순위가 높은 큐에서 낮은 큐로 떨어지는 기준은 어떻게 정할 것인가</li>
      <li>우선순위가 낮은 큐에서 높은 큐로 올라가는 기준은 어떻게 정할 것인가</li>
      <li>처음 프로세스가 들어갈 때 어떤 큐로 들어갈 것이냐</li>
    </ul>
  </li>
  <li>보통은 처음 들어오는 프로세스는 우선순위가 가장 높은 큐에 집어넣음(RR로, q를 짧게 줌) → 아래의 큐로 갈 수록 RR의 q를 길게 줌(결국 마지막 단은 FCFS) → 상위 큐에서 할당 시간을 써도 안되면 점차 하위 큐로 내려가게 됨</li>
  <li>CPU 사용 시간이 짧은 프로세스에게 우선 순위를 많이 주는 스케줄링 방식임 → 사용 시간 예측이 필요 없으나 CPU 사용 시간이 짧은 프로세스가 이점을 얻는 방식!</li>
</ul>

<p><br /></p>

<h3 id="multiple-processor-scheduling">Multiple-Processor Scheduling</h3>

<ul>
  <li>Homogeneous processor인 경우
    <ul>
      <li>Queue에 한 줄로 세워서 각 프로세스가 알아서 꺼내가게 할 수 있음</li>
      <li>반드시 특정 프로세서에서 수행되어야 하는 프로세스가 있는 경우에는 문제가 더 복잡해짐</li>
    </ul>
  </li>
  <li>Load Sharing ← 특정 CPU는 일 하고 나머지 CPU는 놀고 있으면 안됨
    <ul>
      <li>일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 매커니즘 필요함</li>
      <li>별도의 큐를 두는 방법 vs 공동 큐를 사용하는 방법</li>
    </ul>
  </li>
  <li>Symmetric Multiprocessing (SMP)
    <ul>
      <li>모든 CPU가 대등한 것으로, 각 프로세서가 각자 알아서 스케줄링 결정</li>
    </ul>
  </li>
  <li>Asymmetric multiprocessing
    <ul>
      <li>하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따름</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="real-time-scheduling">Real-Time Scheduling</h3>

<p>→ 정해진 시간 안에 반드시 실행이 되어야 하는, deadline이 있는 프로세스일 경우 사용</p>

<ul>
  <li>hard real-time systems: 정해진 시간 안에 반드시 작업이 끝나도록 스케줄링 해야 함</li>
  <li>soft real-time computing: deadline이 있긴 하지만 지키지 못했다고 해서 위험한 상황이 발생하지는 않음. but, 일반 프로세스에 비해서는 높은 우선순위를 갖도록 구현함</li>
</ul>

<p><br /></p>

<h3 id="thread-scheduling">Thread Scheduling</h3>

<ul>
  <li>Local Scheduling
    <ul>
      <li>유저 레벨 스레드의 경우 운영체제가 해당 스레드의 존재를 모르고 사용자 프로세스가 직접 스레드를 관리함</li>
    </ul>
  </li>
  <li>Global Scheduling
    <ul>
      <li>커널 레벨 스레드의 경우 운영체제가 해당 스레드의 존재를 알고 있어 일반 프로세스처럼 커널의 단기 스케줄러가 어떤 스레드를 스케줄할 지 결정함</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="algorithm-evaluation">Algorithm Evaluation</h3>

<p><strong>Queueing model</strong></p>

<ul>
  <li>굉장히 이론적인 방법</li>
  <li>프로세스들의 도착률과 CPU의 처리율이 확률 분포로 주어질 때, 복잡한 수학적 계산을 통해 여러가지 성능 척도 결과를 얻을 수 있음 (throughput, average waiting time, etc.)</li>
</ul>

<p><strong>Implementation(구현) &amp; Measurement(성능 측정)</strong></p>

<ul>
  <li>실제 시스템에 구현해서 그걸 돌려보고 실제 성능을 측정함</li>
  <li>실제 환경을 만드는 것은 어려움</li>
</ul>

<p><strong>Simulation(모의 실험)</strong></p>

<ul>
  <li>가상으로 CPU 스케줄링 프로그램을 작성한 후 프로그램의 CPU 요청을 입력값으로 넣어 어떠한 결과가 나오는지 확인함</li>
  <li>실제 시스템에서 추출한 입력값을 trace라 함</li>
</ul>]]></content><author><name>kji-dec</name></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[반효경 교수님의 2014-1 운영체제 강의를 듣고 정리한 글입니다.]]></summary></entry><entry><title type="html">5. CPU Scheduling 1</title><link href="/jekyll-theme-yat/os/2022/11/29/OS-Study-Week5-1.html" rel="alternate" type="text/html" title="5. CPU Scheduling 1" /><published>2022-11-29T00:00:00+00:00</published><updated>2022-11-29T00:00:00+00:00</updated><id>/jekyll-theme-yat/os/2022/11/29/OS%20Study%20Week5-1</id><content type="html" xml:base="/jekyll-theme-yat/os/2022/11/29/OS-Study-Week5-1.html"><![CDATA[<p>반효경 교수님의 <a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">2014-1 운영체제 강의</a>를 듣고 정리한 글입니다.</p>

<p><br /></p>

<p>프로그램을 실행하게 되면 어떤 프로그램이건 아래의 절차에 따라 실행이 됨(CPU만 연속적으로 쓰는 단계와 I/O를 하는 단계가 반복되며 나타남)</p>

<p><img src="https://user-images.githubusercontent.com/71377968/204443913-c43ca5d3-6196-4ff2-ad4f-a4a15a390fd7.png" alt="image" /></p>

<ul>
  <li>사람과 interactive한 job이 CPU burst와  I/O burst가 빈번하게 번갈아가며 나타남</li>
  <li>과학 계산용 프로그램과 같은 연산이 긴 프로그램은 CPU를 오래 잡게 됨</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/71377968/204443955-7af8208b-1327-470b-867b-945a925464cf.png" alt="image" /></p>

<ul>
  <li>여러 종류의 Job(=Process)이 섞여 있기 때문에 CPU 스케줄링이 필요함 (I/O bound job 때문이라 생각하면 됨)
    <ul>
      <li>Interactive job에게 적절한 response 제공</li>
      <li>CPU와 I/O 장치 등 시스템 자원을 효율적으로 사용</li>
    </ul>
  </li>
  <li>CPU 스케줄링의 두 가지 이슈
    <ul>
      <li>누구에게 CPU를 줄 것인가</li>
      <li>CPU를 넘긴 상황에서 다시 뺏어올 것인가 혹은 계속 CPU를 사용하게 할 것인가</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="프로세스의-특성-분류">프로세스의 특성 분류</h3>

<ol>
  <li>I/O-bound process: CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job → many short CPU bursts</li>
  <li>CPU-bound process: 계산 위주의 job → few very long CPU bursts</li>
</ol>

<p><br /></p>

<h3 id="cpu-scheduler--dispatcher">CPU Scheduler &amp; Dispatcher</h3>

<ul>
  <li>CPU Scheduler → 운영 체제 내의 CPU 스케줄링을 하는 커널 코드
    <ul>
      <li>Ready 상태의 프로세스 중에서 어떤 프로세스에게 CPU를 줄지 고름</li>
    </ul>
  </li>
  <li>Dispatcher → CPU를 넘겨주는 역할을 하는 커널 코드
    <ul>
      <li>CPU의 제어권을 CPU Scheduler에 의해 선택된 프로세스에게 넘김</li>
      <li>이 과정을 <strong>Context switch</strong>라고 함</li>
    </ul>
  </li>
  <li>CPU 스케줄링이 필요한 경우는 프로세스에게 다음과 같은 상태 변화가 있는 경우
    <ol>
      <li>Running → Blocked (ex: I/O 요청 시스템 콜)</li>
      <li>Running → Ready (ex: 할당 시간 만료로 timer interrupt)</li>
      <li>Blocked → Ready (ex: I/O 완료 후의 Interrupt)</li>
      <li>Terminate
        <ul>
          <li>1, 4에서의 스케줄링은 <strong>non-preemptive(비선점)</strong> → 자진 반납</li>
          <li>다른 스케줄링은 <strong>preemptive(선점)</strong> → 강제로 빼앗음 (현대에는 거의 대부분 해당 방식 사용)</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p><br /></p>

<h3 id="scheduling-criteria">Scheduling Criteria</h3>

<p>이때, 척도는 CPU burst 한번에 따른 것임</p>

<p><strong>시스템 입장에서의 성능 척도</strong> → CPU가 일을 많이 하는 것이 중요</p>

<ul>
  <li>CPU utilization(이용률): 전체 시간 중에서 CPU가 놀지 않고 일한 시간의 비율 → CPU는 가능한 바쁘게 일을 시켜라</li>
  <li>Throughput(처리량): 주어진 시간 동안에 몇 개의 작업을 완료했는가</li>
</ul>

<p><br /></p>

<p><strong>프로세스 입장에서의 성능 척도</strong> → 시간이 빨리 처리되는 것이 중요</p>

<ul>
  <li>Turnaround time(소요 시간, 반환 시간): CPU를 사용하러 들어와서 다 사용할 때까지 걸리는 시간
    <ul>
      <li>ready queue에서 기다린 시간 + 실제로 CPU를 사용한 시간</li>
    </ul>
  </li>
  <li>Waiting time(대기 시간): CPU를 사용하려할 때 기다리는 시간</li>
  <li>Response time(응답 시간): 프로세스가 ready queue에 들어와서 처음으로 CPU를 얻기까지 기다린 시간
    <ul>
      <li>waiting time과의 차이 → preemptive 방식의 경우, CPU를 빼앗길 수 있음. 이때, 여러번 ready queue에 들어와서 기다릴 수 있는데, waiting time은 이러한 모든 기다린 시간을 합친 개념임. 반면, response time은 처음 CPU를 얻기까지 기다린 시간임!</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p>비유 예시) 중국집</p>

<ul>
  <li>utilization: 전체 시간 중에서 주방장이 놀지 않고 일한 시간의 비율</li>
  <li>throughput: 중국집에서 단위 시간 당 손님이 몇명 다녀왔는가</li>
  <li>turnaround time: 손님이 중국집에 들어와서 다 먹고 나갈 때까지의 총 시간</li>
  <li>waiting time: 손님이 밥 먹는 시간 말고 총 기다린 시간(코스요리를 시켰을 때, 각 음식을 기다린 시간을 총 합친 것)</li>
  <li>response time: 처음 음식이 나올 때까지 기다린 시간</li>
</ul>

<p><br /></p>

<h3 id="fcfsfirst-come-first-served">FCFS(First-Come First-Served)</h3>

<ul>
  <li>먼저 온 순서대로 처리하는 방식 (비선점형)</li>
  <li>그리 효율적이지 않음 → CPU를 굉장히 오래 잡는 프로세스가 먼저 도착하면 짧게 CPU를 잡는 프로세스들도 오래 기다려야 함</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/71377968/204446593-380ea323-2710-4bbd-a4c8-4ee19348af35.png" alt="image" /></p>

<ul>
  <li>waiting time: P1 = 0, P2 = 24, P3 = 27</li>
  <li>average waiting time = (0 + 24 + 27) / 3 = 17</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/71377968/204449289-72d98691-9a5a-4621-8bb9-58779468b6a4.png" alt="image" /></p>

<ul>
  <li>waiting time: P1 = 6, P2 = 0, P3 = 3</li>
  <li>average waiting time = (6 + 0 + 3) / 3= 3</li>
</ul>

<p>⇒ 어떤 프로세스가 먼저 도착하냐에 따라 기다리는 시간이 영향을 많이 받음</p>

<ul>
  <li><strong>Convoy effect</strong>: 짧은 프로세스가 긴 프로세스 뒤에 있어 오래 기다려야 하는 현상</li>
</ul>

<p><br /></p>

<h3 id="sjfshortest-job-first">SJF(Shortest-Job-First)</h3>

<ul>
  <li>CPU를 사용하고자 하는 시간이 가장 짧은 프로세스에게 CPU를 먼저 줌 → 전체적인 큐가 짧아짐</li>
  <li>주어진 프로세스들에 대해 <strong>minimum average waiting time</strong>을 보장함(preemptive 방식에 대해)</li>
  <li>두 가지 방식
    <ul>
      <li>Nonpreemptive: 가장 짧은 프로세스가 도착하여 실행 중일 때, 더 짧은 프로세스가 도착하여도 CPU를 넘겨주지 않는 방식</li>
      <li>Preemptive: 더 짧은 프로세스가 도착하면 CPU를 빼앗기는 방식</li>
      <li>Shortest-Remaining-Time-First(SRTF)라고도 부름 → 남은 시간이 가장 짧은 애를 먼저 실행</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/71377968/204450723-ae20a8f5-5411-4287-9028-705200ec23aa.png" alt="image" /></p>

<p>→ CPU를 다 쓰고 나가는 시점에 스케줄링을 할지 말지 정함</p>

<p><img src="https://user-images.githubusercontent.com/71377968/204450691-db9a508b-c978-4340-b031-a11ad21d1cd1.png" alt="image" /></p>

<p>→ 프로세스가 도착하는 시점에 스케줄링을 할지 말지 정함</p>

<p><br /></p>

<p><strong>문제점</strong></p>

<ul>
  <li>Starvation(기아 현상): SJF는 극단적으로 CPU 사용이 짧은 job을 선호하므로, CPU 사용 시간이 긴 프로세스는 영원히 실행되지 않을 수 있음</li>
  <li>CPU 사용 시간을 미리 알 수 없음
    <ul>
      <li>추정값 이용 가능(과거의 CPU 사용 시간을 이용해 추정 가능 ← <strong>exponential averaging</strong>)</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/71377968/204452082-a757b3c4-1b8d-48c1-ba39-66466fdad049.png" alt="image" /></p>

<p><br /></p>

<h3 id="priority-scheduling">Priority Scheduling</h3>

<ul>
  <li>우선 순위가 제일 높은 프로세스에게 CPU를 주는 것</li>
  <li>두 가지 방식
    <ul>
      <li>preemptive: 중간에 우선순위가 더 높은 프로세스가 오면 넘겨줌</li>
      <li>nonpreemptive: CPU를 한 번 잡으면 넘겨주지 않음</li>
    </ul>
  </li>
  <li>SJF도 우선순위 스케줄링의 일종임 (우선순위 ⇒ CPU 사용 시간)</li>
  <li>문제점: Starvation ⇒ 해결: Aging(시간이 지날수록 우선순위를 높여줌)</li>
</ul>

<p><br /></p>

<h3 id="round-robinrr">Round Robin(RR)</h3>

<ul>
  <li>현대적인 CPU 스케줄링</li>
  <li>CPU를 줄 때 동일한 크기의 할당 시간을 세팅해서 주게 되고, 해당 할당 시간이 끝나면 timer interrupt에 의해 ready queue의 제일 뒤에 줄을 서게 됨</li>
  <li>응답 시간이 빨라진다는 장점이 있음 → 누구든지 짧은 시간만 기다리면 CPU를 사용할 수 있음</li>
  <li>n개의 프로세스가 ready queue에 있고, 할당 시간을 q라고 잡았을 때 q time unit 단위로 CPU 시간의 1/n을 얻을 수 있음 → 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않게 됨.
    <ul>
      <li>q를 아주 짧게 잡으면 CPU를 사용할 수 있는 시간이 빨리 돌아옴</li>
      <li>대기 시간이 본인이 CPU를 사용하는 시간에 비례하게 됨</li>
    </ul>
  </li>
  <li>성능
    <ul>
      <li>q가 클 경우 → FCFS</li>
      <li>q가 작을 경우 → context switch라는 오버헤드가 커짐</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/71377968/204469472-2431512e-05b0-4f2a-b743-d5d03d1be90f.png" alt="image" /></p>

<p>→ q가 20인 경우의 예시</p>

<ul>
  <li>일반적으로 SJF보다 average turnaround time이 길지만 response time은 더 짧아짐</li>
  <li>CPU 사용 시간이 동일한 경우에는 RR을 사용하게 되면 비효율적일 수 있으나, 그런 경우는 드문 경우임</li>
</ul>]]></content><author><name>kji-dec</name></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[반효경 교수님의 2014-1 운영체제 강의를 듣고 정리한 글입니다.]]></summary></entry><entry><title type="html">4. Process Management 1, 2</title><link href="/jekyll-theme-yat/os/2022/11/27/OS-Study-Week4.html" rel="alternate" type="text/html" title="4. Process Management 1, 2" /><published>2022-11-27T00:00:00+00:00</published><updated>2022-11-27T00:00:00+00:00</updated><id>/jekyll-theme-yat/os/2022/11/27/OS%20Study%20Week4</id><content type="html" xml:base="/jekyll-theme-yat/os/2022/11/27/OS-Study-Week4.html"><![CDATA[<p>반효경 교수님의 <a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">2014-1 운영체제 강의</a>를 듣고 정리한 글입니다.</p>

<p><br /></p>

<h3 id="프로세스-생성-process-creation">프로세스 생성 (Process Creation)</h3>

<ul>
  <li>부모 프로세스(Parent process)가 자식 프로세스(Child process)를 생성함
    <ul>
      <li>주로 “복제”를 이용 → 프로세스의 문맥을 복제</li>
    </ul>
  </li>
  <li>프로세스의 트리(계층 구조) 형성</li>
  <li>프로세스는 자원을 필요로 함
    <ul>
      <li>운영체제로부터 받음</li>
      <li>부모와 공유하는 모델도 있고 아닌 경우도 있음</li>
    </ul>
  </li>
  <li>자원의 공유
    <ul>
      <li>부모와 자식이 모든 자원을 공유하는 모델</li>
      <li>일부를 공유하는 모델</li>
      <li>전혀 공유하지 않는 모델 (→ 이게 일반적인 경우. 부모와 자식은 서로 CPU를 얻으려고 경쟁하게 됨)</li>
      <li>Copy-on-write: 계속 공유하고 있다가 달라지는 점이 있을 때, 그 부분을 copy함</li>
    </ul>
  </li>
  <li>수행 (Execution)
    <ul>
      <li>부모와 자식은 공존하며 수행되는 모델</li>
      <li>자식이 종료(terminate)될 때까지 부모가 기다리는(wait - blocked) 모델</li>
    </ul>
  </li>
  <li>주소 공간(Address space)
    <ul>
      <li>자식은 부모의 공간을 복사함 (binary and OS data)</li>
      <li>자식은 그 공간에 새로운 프로그램을 올림</li>
    </ul>
  </li>
  <li>유닉스의 예
    <ul>
      <li>fork() 시스템 콜이 새로운 프로세스를 생성함
        <ul>
          <li>부모를 그대로 복사(OS data except PID + binary)</li>
          <li>주소 공간 할당</li>
        </ul>
      </li>
      <li>fork() 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림 → 새로운 프로그램으로 주소 공간을 덮어 씌우는 것</li>
      <li>이때 fork, exec은 모두 시스템 콜임. OS의 일!</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="프로세스-종료process-termination">프로세스 종료(Process Termination)</h3>

<ul>
  <li>프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌 (exit) - 자발적
    <ul>
      <li>자식이 부모에게 output data를 보냄 (wait) - 자식이 먼저 종료되고, 부모는 뒷일을 처리하는 구조</li>
      <li>프로세스의 각종 자원들이 운영체제에게 반납됨</li>
    </ul>
  </li>
  <li>부모 프로세스가 자식의 수행을 종료시킴 (abort) - 비자발적
    <ul>
      <li>자식이 할당 자원의 한계치를 넘어선 경우</li>
      <li>자식에게 할당된 태스크가 더이상 필요하지 않은 경우</li>
      <li>부모가 종료(exit)하는 경우
        <ul>
          <li>운영체제는 부모 프로세스가 종료하는 경우 자식이 더이상 수행되도록 두지 않음</li>
          <li>단계적인 종료가 이루어짐</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="fork-시스템-콜">fork() 시스템 콜</h3>

<ul>
  <li>프로세스는 fork() 시스템 콜에 의해 생성됨
    <ul>
      <li>creates a new address space that is a duplicate of the caller</li>
    </ul>
  </li>
  <li>child는 fork 시점부터 실행하게 됨
    <ul>
      <li>parent의 context (PC)를 복사하므로 어디서부터 실행해야하는지 알 수 있음</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>  <span class="c1">//child</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\\</span><span class="s">n Hello, i am child!</span><span class="se">\\</span><span class="s">n"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span> <span class="c1">//parent</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\\</span><span class="s">m Hello, i am parent!</span><span class="se">\\</span><span class="s">n"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="exec-시스템-콜">exec() 시스템 콜</h3>

<ul>
  <li>프로그램은 exec() 시스템 콜에 의해 다른 프로세스가 될 수 있음
    <ul>
      <li>replaces the memory image of the caller with a new program</li>
    </ul>
  </li>
  <li>exec() 시스템 콜을 실행하면 새로운 프로그램으로 덮어씌워지고 처음부터(main부터) 실행하게 됨</li>
  <li>한번 exec() 시스템 콜을 실행하면 되돌아갈 수 없음</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">pud</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>  <span class="c1">//child</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\\</span><span class="s">n Hello, i am child! Now i'll run date </span><span class="se">\\</span><span class="s">n"</span><span class="p">);</span>
        <span class="n">execlp</span><span class="p">(</span><span class="s">"/bin/date"</span><span class="p">,</span> <span class="s">"/bin/date"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">){</span>  <span class="c1">//parent</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\\</span><span class="s">n Hello, i am parent!</span><span class="se">\\</span><span class="s">n"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>꼭 자식 프로세스를 생성한 후 exec을 실행해야하는 건 아님! (아래와 같은 경우도 가능)</li>
  <li>단, exec 이후의 코드인 parent 출력문은 영원히 실행되지 않음 ← 새로운 프로그램으로 덮어씌워졌기 때문</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\\</span><span class="s">n Hello, i am child! Now i'll run date </span><span class="se">\\</span><span class="s">n"</span><span class="p">);</span>
    <span class="n">execlp</span><span class="p">(</span><span class="s">"/bin/date"</span><span class="p">,</span> <span class="s">"/bin/date"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\\</span><span class="s">n Hello, i am parent!</span><span class="se">\\</span><span class="s">n"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="wait-시스템-콜">wait() 시스템 콜</h3>

<ul>
  <li>프로세스 A가 wait() 시스템 콜을 호출하면
    <ul>
      <li>커널은 child가 종료될 때까지 프로세스 A를 sleep 시킴 (block)</li>
      <li>child process가 종료되면 커널은 프로세스 A를 깨움 (ready)</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/71377968/204136101-039f19fc-6c88-4ea7-a911-71374c910bac.png" alt="image" /></p>

<ul>
  <li>위 사진의 경우, 부모 프로세스에서 wait 호출이 있음 → 자식 프로세스의 코드가 모두 수행된 후 종료된 시점에 else를 빠져나가 다음 코드를 실행할 수 있음
    <ul>
      <li>ex: 리눅스의 쉘 프롬프트</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="exit-시스템-콜">exit() 시스템 콜</h3>

<ul>
  <li>프로세스를 종료시킬 때 호출하는 시스템 콜</li>
  <li>자발적 종료
    <ul>
      <li>마지막 statement 수행 후 exit() 시스템 콜을 통해</li>
      <li>프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌</li>
    </ul>
  </li>
  <li>비자발적 종료
    <ul>
      <li>부모 프로세스가 자식 프로세스를 강제 종료시킴
        <ul>
          <li>자식 프로세스가 한계치를 넘어서는 자원 요청</li>
          <li>자식에게 할당된 태스크가 더 이상 필요하지 않음</li>
        </ul>
      </li>
      <li>키보드로 kill, break 등을 친 경우</li>
      <li>부모가 종료하는 경우
        <ul>
          <li>부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="프로세스-간-협력">프로세스 간 협력</h3>

<ul>
  <li>독립적 프로세스 (Independent process)
    <ul>
      <li>프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함</li>
    </ul>
  </li>
  <li>협력 프로세스 (Cooperating process)
    <ul>
      <li>프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음</li>
    </ul>
  </li>
  <li>프로세스 간 협력 메커니즘(<strong>IPC</strong>: Interprocess Communication)
    <ul>
      <li>메시지를 전달하는 방법 - <strong>message passing</strong>: 커널을 통해 메시지 전달</li>
      <li>주소 공간을 공유하는 방법 - <strong>shared memory</strong>: 서로 다른 프로세스 간 일부 주소 공간을 공유하게 하는 메커니즘
        <ul>
          <li>shared memory의 사용을 위해서는 해당 프로세스들이 신뢰할 수 있는 관계여야 함</li>
          <li>Thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 프로세스를 구성하는 Thread들 간에는 주소 공간을 공유하므로 협력이 가능</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/71377968/204136544-3c7c50fc-e709-4001-a37e-63dc1f0d68b0.png" alt="image" /></p>

<p><br /></p>

<h3 id="message-passing">Message Passing</h3>

<p>원칙적으로 프로세스는 독립적이기 때문에 메시지를 서로 직접 전달할 수 없음 → 커널 이용</p>

<ul>
  <li>Message system: 프로세스 사이에 공유 변수를 일체 사용하지 않고 통신하는 시스템</li>
</ul>

<ol>
  <li>Direct Communication: 통신하려는 프로세스의 이름을 명시적으로 표시</li>
</ol>

<p><img src="https://user-images.githubusercontent.com/71377968/204136558-d7303e9d-28d4-46e5-9353-5fb79d4758b7.png" alt="image" /></p>

<ol>
  <li>Indirect Communication: mailbox 또는 port를 통해 메시지를 간접 전달</li>
</ol>

<p><img src="https://user-images.githubusercontent.com/71377968/204136564-1c325b65-4af9-4874-8bae-bcebe07eaf31.png" alt="image" /></p>

<ul>
  <li>위의 두 경우 모두 커널을 사용하는 건 동일!</li>
</ul>]]></content><author><name>kji-dec</name></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[반효경 교수님의 2014-1 운영체제 강의를 듣고 정리한 글입니다.]]></summary></entry><entry><title type="html">3-1. Process 1</title><link href="/jekyll-theme-yat/os/2022/11/20/OS-Study-Week3-1.html" rel="alternate" type="text/html" title="3-1. Process 1" /><published>2022-11-20T00:00:00+00:00</published><updated>2022-11-20T00:00:00+00:00</updated><id>/jekyll-theme-yat/os/2022/11/20/OS%20Study%20Week3-1</id><content type="html" xml:base="/jekyll-theme-yat/os/2022/11/20/OS-Study-Week3-1.html"><![CDATA[<p>반효경 교수님의 <a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">2014-1 운영체제 강의</a>를 듣고 정리한 글입니다.</p>

<p><br /></p>

<h3 id="프로세스의-개념">프로세스의 개념</h3>

<p>프로세스: 실행 중인 프로그램</p>

<ul>
  <li>
    <p>프로세스의 문맥; 이 프로그램이 무엇을 어떻게 실행했는지,</p>

    <p>현재 시점이 어떤 상태에 있는지</p>

    <p>를 정확하게 나타내기 위한 것</p>

    <ul>
      <li>예시
        <ul>
          <li>PC(Program Counter)가 코드의 어느 부분을 가리키고 있는가</li>
          <li>프로세스의 메모리에 어떤 내용을 담고 있는가</li>
          <li>함수가 호출된 상태였다면 스택에 뭔가가 쌓여있을 텐데 현재 어디까지 쌓여있는가</li>
          <li>데이터 영역의 변수의 값은 얼마인가</li>
          <li>레지스터에 어떤값을 넣어 놓고 어떤 인스트럭션까지 실행했는가 등</li>
        </ul>
      </li>
      <li>CPU 수행 상태를 나타내는 하드웨어 문맥: PC, 각종 레지스터</li>
      <li>프로세스의 주소 공간(메모리와 관련): code, data, stack</li>
      <li>프로세스 관련 커널 자료 구조: PCB(Process Control Block), Kernel stack</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="프로세스의-상태">프로세스의 상태</h3>

<p>→ 프로세스는 상태를 변경하며 수행 됨</p>

<p><img src="https://user-images.githubusercontent.com/71377968/202898046-6d9d65f2-6bfd-40ef-a43f-ad9c0b285f72.png" alt="image" /></p>

<ul>
  <li>Running: CPU를 잡고 인스트럭션을 수행 중인 상태</li>
  <li>Ready: 메모리 등 다른 조건을 모두 만족하고 CPU를 기다리는 상태</li>
  <li>Blocked(wait, sleep)
    <ul>
      <li>CPU를 주어도 당장 인스트럭션을 수행할 수 없는 상태</li>
      <li>프로세스 자신이 요청한 이벤트(예: I/O와 같은 오래 걸리는 작업)가 즉시 만족되지 않아 이를 기다리는 상태</li>
      <li>ex: 디스크에서 파일을 읽어와야 하는 경우</li>
    </ul>
  </li>
  <li>경우에 따라 추가되는 상태
    <ul>
      <li>New: 프로세스가 생성 중인 상태</li>
      <li>Terminated: 프로세스의 수행이 끝난 상태(약간 정리할 게 남아 있는 그런 상태 → 완전히 끝나면 프로세스가 아님)</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/71377968/202898163-bf600c8f-9384-4909-8518-2f86b2b93ba2.png" alt="image" /></p>

<ul>
  <li>예시
    <ul>
      <li>running 상태의 프로세스가 사용자로부터 키보드 입력을 받아서 결과를 보고 실행한다고 가정했을때, 해당 프로세스는 keyboard I/O queue에 줄을 서게 됨(running → blocked)</li>
      <li>키보드 입력을 받으면 keyboard controller가 CPU에게 인터럽트를 걸어서 알려주면, CPU는 하던 일을 멈추고 운영체제에게 넘어가서 프로세스 상태를 ready로 바꿈(blocked → ready)</li>
    </ul>
  </li>
  <li>하드웨어 뿐만 아니라 공유데이터에 동시에 접근하는 경우나 어떠한 오래 걸리는 작업을 하면 프로세스는 blocked 상태가 될 수 있음</li>
  <li>또, 여기의 queue는 운영체제 커널의 data 영역에 있는 것임</li>
</ul>

<p><br /></p>

<h3 id="pcb">PCB</h3>

<p>운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보</p>

<p>아래의 구성 요소를 구조체로 유지하며 가짐</p>

<ul>
  <li>OS가 관리상 사용하는 정보
    <ul>
      <li>Process state, Process ID</li>
      <li>scheduling information, priority</li>
    </ul>
  </li>
  <li>CPU 수행 관련 하드웨어 값
    <ul>
      <li>Program counter, registers</li>
    </ul>
  </li>
  <li>메모리 관련
    <ul>
      <li>Code, data, stack의 위치 정보</li>
    </ul>
  </li>
  <li>파일 관련
    <ul>
      <li>Open file descriptors 등</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="문맥-교환">문맥 교환</h3>

<p>CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정</p>

<ul>
  <li>과정
    <ul>
      <li>CPU를 내어주는 프로세스 상태를 해당 프로세스의 PCB에 저장</li>
      <li>CPU를 새롭게 얻는 프로세스의 상태를 해당 프로세스의 PCB에서 읽어옴</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/71377968/202899040-1d407baf-d006-4a1c-8459-a5a4c4926e74.png" alt="image" /></p>

<ul>
  <li>이때, System call이나 인터럽트 발생 시 반드시 context switch가 일어나는 것은 아님
    <ul>
      <li>CPU가 운영체제로 넘어가는 것은 context switch가 아님!! 만약 운영체제가 여기서 다른 프로세스로 CPU를 넘겨줘야만 context switch가 되는 것</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>프로세스를 스케줄링하기 위한 큐</strong></p>

<ul>
  <li>Job queue: 현재 시스템 내에 있는 모든 프로세스의 집합</li>
  <li>Ready queue: 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합</li>
  <li>Device queue: I/O device의 처리를 기다리는 프로세스의 집합</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/71377968/202899321-b2354848-e201-4756-b5a6-5b795a0ecfaa.png" alt="image" /></p>

<p><br /></p>

<h3 id="스케줄러">스케줄러</h3>

<ul>
  <li>Long-term scheduler(장기 스케줄러 or job scheduler) → 지금의 시스템에는 없음
    <ul>
      <li>메모리를 어떤 프로세스에게 줄 지 결정</li>
      <li>프로세스가 new → ready 상태로 변환될 때 admit되는 게 메모리에 admit되는 건데 여기서 장기 스케줄러가 해당 프로세스에 메모리를 줄지 안 줄지 결정하는 것</li>
      <li>degree of Multiprogramming(메모리에 올라가있는 프로세스의 수)을 제어함</li>
      <li>time sharing system에는 무조건 ready 상태로 올리기 때문에 보통 장기 스케줄러가 없음</li>
    </ul>
  </li>
  <li>Short-term scheduler(단기 스케줄러 or CPU scheduler)
    <ul>
      <li>굉장히 짧은 시간 단위(millisecond 단위)로 스케줄링이 일어남</li>
      <li>다음번에 어떤 프로세스에게 CPU를 줄 지 결정</li>
    </ul>
  </li>
  <li>Medium-term scheduler(중기 스케줄러 or Swapper) → 지금의 시스템
    <ul>
      <li>여유 공간 마련을 위해 일부 프로세스를 통째로 메모리에서 디스크로 쫓아냄 → degree of Multiprogramming 제어</li>
      <li>프로세스에서 메모리를 빼앗는 문제</li>
    </ul>
  </li>
  <li>중기 스케줄러의 존재로 새로 정의된 프로세스의 상태 → <strong>Suspended(stopped)</strong>
    <ul>
      <li>외부적인 이유로 프로세스의 수행이 정지된 상태</li>
      <li>프로세스는 통째로 디스크에 swap out됨</li>
      <li>예시
        <ul>
          <li>사용자가 프로그램을 일시 정지시킨 경우(break key) 시스템이 여러 이유로 프로세스를 잠시 중단시킴</li>
          <li>메모리에 너무 많은 프로세스가 올라와 있을 때 중기 스케줄러가 정지시킴</li>
          <li>사람이 ctrl-z 키를 누른다던가 해서 프로세스를 정지시키는 경우에도 suspended 상태가 됨. 이때 active 되려면 사람이 다시 실행해줘야함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Suspended와 Blocked 상태 구분
    <ul>
      <li>blocked: 자신이 요청한 이벤트가 만족되면 ready 상태로 변환</li>
      <li>suspended: 외부에서 resume을 해주어야만 active됨</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="프로세스-상태도suspended-포함">프로세스 상태도(suspended 포함)</h3>

<p><img src="https://user-images.githubusercontent.com/71377968/202899909-5965645c-0bb0-40b1-9185-26ce47e66aa9.png" alt="image" /></p>

<ul>
  <li>Running 상태
    <ul>
      <li>user mode: 프로세스를 CPU를 가지고 있으면서 본인의 코드를 실행 중인 상태</li>
      <li>kernel mode: system call이나 interrupt 혹은 trap으로 인해 운영체제의 코드가 실행 중인 상태</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><br /></p>

<p>[사진 출처] <a href="https://hyojaedev.tistory.com/30">https://hyojaedev.tistory.com/30</a></p>]]></content><author><name>kji-dec</name></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[반효경 교수님의 2014-1 운영체제 강의를 듣고 정리한 글입니다.]]></summary></entry><entry><title type="html">3-2. Process 2, 3</title><link href="/jekyll-theme-yat/os/2022/11/20/OS-Study-Week3-2.html" rel="alternate" type="text/html" title="3-2. Process 2, 3" /><published>2022-11-20T00:00:00+00:00</published><updated>2022-11-20T00:00:00+00:00</updated><id>/jekyll-theme-yat/os/2022/11/20/OS%20Study%20Week3-2</id><content type="html" xml:base="/jekyll-theme-yat/os/2022/11/20/OS-Study-Week3-2.html"><![CDATA[<p>반효경 교수님의 <a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">2014-1 운영체제 강의</a>를 듣고 정리한 글입니다.</p>

<p><br /></p>

<h3 id="수업-전-qa">수업 전 Q&amp;A</h3>

<p>동기식 입출력과 비동기식 입출력의 차이</p>

<ul>
  <li>동기식 입출력
    <ul>
      <li>어떤 프로세스가 입출력 요청을 했을 때, 운영체제를 통해서 해야하므로 프로세스는 운영체제에 입출력 요청을 함. 그리고 해당 프로세스가 입출력이 끝날 때까지 아무것도 안 하고 기다려야 하는 경우</li>
      <li>구현 방법
        <ul>
          <li>CPU를 가지고 있으면서 기다리게 구현 → CPU 낭비</li>
          <li>당장 일을 할 수 있는 다른 프로세스에게 CPU를 넘겨주게 구현 → 일반적으로 구현하는 방법</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>비동기식 입출력
    <ul>
      <li>프로세스가 입출력 요청을 한 후 그 프로세스가 곧바로 CPU를 잡아 인스트럭션을 수행하는 경우</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="thread">Thread</h3>

<p>프로세스 내부에 CPU 수행 단위가 여러개 있는 것</p>

<p>A thread (or lightweight process) is a basic unit of CPU utilization</p>

<p><img src="https://user-images.githubusercontent.com/71377968/202900957-83ad52f0-865e-47ae-8315-c428cb918360.png" alt="image" /></p>

<ul>
  <li>Thread의 구성
    <ul>
      <li>program counter</li>
      <li>register set</li>
      <li>stack space</li>
    </ul>
  </li>
  <li>Thread가 동료 thread와 공유하는 부분(=task)
    <ul>
      <li>code section</li>
      <li>data section</li>
      <li>OS resources</li>
    </ul>
  </li>
  <li>전통적인 개념의 heavyweight process 는 하나의 thread를 가지고 있는 task로 볼 수 있음</li>
</ul>

<p><br /></p>

<h3 id="thread-사용의-장점">Thread 사용의 장점</h3>

<ul>
  <li>Responsiveness(응답성)
    <ul>
      <li>사용자 입장에서 빠름</li>
      <li>웹브라우저에 접속한다고 할 때 html 화면에 그림이 있는 경우 이를 해석하여 서버에서 이미지를 가져온 후 그걸 확인하여 화면을 완성하면 사용자에게 보여주는데, 이 과정에서 이미지를 불러올 때, 이는 오래 걸리는 작업이므로 block을 시킬 것임. 하지만 여러개의 스레드를 사용하면 이미지를 요청한는 스레드만 block이 되므로 다른 스레드가 이미 읽어온 html 문서라도 화면에 디스플레이해줄 수 있음 → 일종의 비동기식 입출력</li>
    </ul>
  </li>
  <li>Resource Sharing(자원 공유)
    <ul>
      <li>똑같은 일을 하는 프로그램이 여러개 있는 것 보다 하나의 프로세스를 만들고 그 안에 CPU 수행 단위만 여러개 두게 되면 code, data, 각종 자원을 공유하여 자원을 효율적으로 사용하는 효과를 얻을 수 있음</li>
    </ul>
  </li>
  <li>Economy(경제성)
    <ul>
      <li>응답성과는 다른 의미로 빠름</li>
      <li>프로세스를 하나 생성(creating)하고 문맥교환(switching) 하는 것보다 스레드를 하나 생성하고 문맥교환하는 것이 오버헤드가 더 적음(switching의 경우, 동일한 주소 공간을 사용하므로 스레드를 사용하는 것이 더 경제적)</li>
    </ul>
  </li>
  <li>Utilization of MP(Multi Processor) Architectures
    <ul>
      <li>CPU가 여러개 있는 경우에만 해당</li>
      <li>서로 다른 CPU에서 병렬적으로 작업하여 결과를 빠르게 얻을 수 있음</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="스레드-구현-방식">스레드 구현 방식</h3>

<ul>
  <li>Kernel Threads: 운영체제의 지원을 받음
    <ul>
      <li>스레드가 여러개 있다는 사실을 운영체제가 알고 있음</li>
      <li>스레드를 수행하는 것도 커널이 CPU 스케줄링을 하듯이 넘겨주게 됨</li>
    </ul>
  </li>
  <li>User Threads: 라이브러리 형태로 구현
    <ul>
      <li>스레드가 여러개 있다는 사실을 운영체제가 모름</li>
      <li>유저 프로그램이 스스로 여러개의 스레드를 라이브러리의 지원을 받아 관리함</li>
      <li>운영체제가 모르기 때문에 구현 상의 제약점이 있을 수 있음</li>
    </ul>
  </li>
  <li>Real-Time Threads</li>
</ul>

<p><br /></p>

<p><br /></p>

<p>[사진 출처] <a href="https://hyojaedev.tistory.com/30">https://hyojaedev.tistory.com/30</a></p>]]></content><author><name>kji-dec</name></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[반효경 교수님의 2014-1 운영체제 강의를 듣고 정리한 글입니다.]]></summary></entry><entry><title type="html">2-1. System Structure &amp;amp; Program Execution 1</title><link href="/jekyll-theme-yat/os/2022/11/11/OS-Study-Week2-1.html" rel="alternate" type="text/html" title="2-1. System Structure &amp;amp; Program Execution 1" /><published>2022-11-11T00:00:00+00:00</published><updated>2022-11-11T00:00:00+00:00</updated><id>/jekyll-theme-yat/os/2022/11/11/OS%20Study%20Week2-1</id><content type="html" xml:base="/jekyll-theme-yat/os/2022/11/11/OS-Study-Week2-1.html"><![CDATA[<p>반효경 교수님의 <a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">2014-1 운영체제 강의</a>를 듣고 정리한 글입니다.</p>

<p><br /></p>

<h3 id="컴퓨터-시스템-구조">컴퓨터 시스템 구조</h3>

<p><img src="https://user-images.githubusercontent.com/71377968/201288523-a2bb4dfe-3967-40d9-b83e-23d4c9c48079.png" alt="image" />
<img src="https://user-images.githubusercontent.com/71377968/201288578-020a7768-b55c-4e8e-8fd9-04e80544a120.png" alt="image" /></p>

<p><strong>device controller</strong>: I/O 디바이스를 전담하는 작은 CPU 같은 것(HW)</p>

<ul>
  <li>ex: 디스크의 내부 컨트롤은 디바이스 컨트롤러가 맡음</li>
  <li>제어 정보를 위해 control register, status register를 가짐</li>
  <li>local buffer: device controller의 작업 공간</li>
  <li>I/O는 실제 device와 local buffer 사이에서 일어남</li>
  <li>I/O가 끝났을 경우 device controller는 interrupt로 CPU에 그 사실을 알림</li>
</ul>

<p>*device driver(장치구동기): OS 코드 중 각 장치별 처리 루틴(SW)</p>

<p><br /></p>

<p><strong>CPU</strong>는 메모리에 있는 인스트럭션을 불러와서 실행하고 interrupt line을 체크함</p>

<p>register: 메모리보다 더 빠른 CPU 내의 저장 공간</p>

<p><strong>mode bit</strong>: CPU에서 실행되는 것이 운영체제인지 사용자 프로그램인지 구분해주는 것</p>

<ul>
  <li>모니터모드[0] (커널 모드, 시스템 모드): 운영체제가 CPU에서 수행중인 것
    <ul>
      <li>CPU는 I/O device 접근, 메모리 접근 등 모든 것을 다 할 수 있음</li>
    </ul>
  </li>
  <li>사용자모드[1]: 사용자 프로그램이 CPU에서 수행중인 것
    <ul>
      <li>제한된 instruction만 CPU에서 할 수 있음</li>
    </ul>
  </li>
</ul>

<p><strong>interrupt line</strong>: 요청을 전달하는 곳</p>

<p><br /></p>

<p><strong>timer</strong>: 특정 프로그램이 CPU를 독점하는 것을 막기 위한 하드웨어(사용자 프로그램에게 timer에 할당된 시간에 따라 CPU를 넘겨줌(→ timer의 시간이 되면 interrupt로 CPU에게 사용 시간이 끝남을 알리고 CPU 제어권이 운영체제로 넘어감)</p>

<p><br /></p>

<p><strong>DMA controller</strong>(Direct Memory Access controller): 원래는 메모리에는 CPU만 접근할 수 있으나 DMA controller도 접근할 수 있음</p>

<ul>
  <li>I/O device에서 다수의 인터럽트를 발생시키고, 모든 인터럽트에 대해 CPU가 실시간 대응하면 CPU 사용에 있어서 오버헤드 발생 → DMA가 I/O의 데이타(I/O 디바이스의 buffer의 값)를 모음 → 데이터를 바이트가 아닌 block 단위로 한 번에 메모리에 접근해서 저장하며, 처리 결과를 단 한 번의 인터럽트로 cpu에 전달.</li>
</ul>

<p><br /></p>

<p><strong>memory controller</strong>: 특정 메모리 영역을 동시에 접근하려고 할 때 문제가 발생할 수 있으므로 해당 문제를 중재하기 위한 역할을 수행함</p>

<p><br /></p>

<p>*I/O 작업은 보안 상의 이유로 OS가 하게 됨</p>

<p>사용자 프로그램에서 I/O device를 사용하려고 하면 알아서 OS로 CPU를 넘겨주게 됨(그 이후에는 다른 프로그램이 CPU를 넘겨 받음)</p>

<p>→ I/O device의 처리가 끝나면 device controller가 interrupt를 걸고, 해당 interrupt에 따라 CPU 제어권은 OS에 넘어가게 됨</p>

<p>→ CPU를 넘겨받은 OS는 interrupt의 이유를 파악해 I/O device의 결과값을 해당 사용자 프로그램으로 넘겨주게 되고 일반적으로는 기존에 실행 중이던 프로그램의 시간이 남았으면 그 프로그램이 계속 실행됨</p>

<p>→ 언젠가는 I/O가 끝난 프로그램이 실행되는 것</p>

<p><br /></p>

<h3 id="io의-수행"><strong>I/O의 수행</strong></h3>

<ul>
  <li>모든 입출력 명령은 특권 명령임 (OS의 소관)</li>
  <li>사용자 프로그램의 I/O 수행
    <ul>
      <li>시스템콜(system call): 사용자 프로그램은 운영체제에게 I/O 요청</li>
      <li>trap을 사용하여 인터럽트 벡터의 특정 위치로 이동</li>
      <li>제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동</li>
      <li>올바른 I/O 요청인지 확인 후 I/O 수행</li>
      <li>I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="인터럽트"><strong>인터럽트</strong></h3>

<ul>
  <li>인터럽트 당한 시점의 레지스터와 program counter를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘김</li>
  <li>넓은 의미의 interrupt
    <ul>
      <li>interrupt(HW interrupt): 하드웨어가 발생시킨 인터럽트</li>
      <li>Trap(SW interrupt): Exception(프로그램이 오류를 범한 경우), System call(프로그램이 커널 함수를 호출하는 경우)</li>
    </ul>
  </li>
  <li>인터럽트 벡터: 해당 인터럽트의 처리 루틴 주소를 가지고 있음</li>
  <li>인터럽트 처리 루틴(Interrupt Service Routine, 인터럽트 핸들러): 해당 인터럽트를 처리하는 커널 함수</li>
</ul>

<p>*현대의 운영체제는 인터럽트에 의해 구동됨(OS는 인터럽트가 들어오는 경우에만 CPU를 사용하게 됨)</p>]]></content><author><name>kji-dec</name></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[반효경 교수님의 2014-1 운영체제 강의를 듣고 정리한 글입니다.]]></summary></entry><entry><title type="html">2-2. System Structure &amp;amp; Program Execution 2</title><link href="/jekyll-theme-yat/os/2022/11/11/OS-Study-Week2-2.html" rel="alternate" type="text/html" title="2-2. System Structure &amp;amp; Program Execution 2" /><published>2022-11-11T00:00:00+00:00</published><updated>2022-11-11T00:00:00+00:00</updated><id>/jekyll-theme-yat/os/2022/11/11/OS%20Study%20Week2-2</id><content type="html" xml:base="/jekyll-theme-yat/os/2022/11/11/OS-Study-Week2-2.html"><![CDATA[<p>반효경 교수님의 <a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">2014-1 운영체제 강의</a>를 듣고 정리한 글입니다.</p>

<p><br /></p>

<h3 id="동기식-입출력과-비동기식-입출력">동기식 입출력과 비동기식 입출력</h3>

<p><img src="https://user-images.githubusercontent.com/71377968/201299188-379d8c9e-91cd-447d-a05b-71fee9e4fb5b.png" alt="image" /></p>

<p><strong>Synchronous I/O</strong></p>

<ul>
  <li>I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감</li>
  <li>구현방법 1
    <ul>
      <li>I/O가 끝날 때까지 CPU를 낭비시킴</li>
      <li>매시점 하나의 I/O만 일어날 수 있음</li>
    </ul>
  </li>
  <li>구현방법 2 ✔️
    <ul>
      <li>I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음</li>
      <li>I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움</li>
      <li>다른 프로그램에게 CPU를 줌</li>
    </ul>
  </li>
</ul>

<p><strong>Asynchronous I/O</strong></p>

<ul>
  <li>I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감</li>
  <li>→ write의 경우 일반적으로 비동기식이 자연스러움</li>
</ul>

<p>*두 경우 모두 I/O의 완료는 인터럽트로 알려줌</p>

<p><br /></p>

<h3 id="서로-다른-입출력-명령어">서로 다른 입출력 명령어</h3>

<p><img src="https://user-images.githubusercontent.com/71377968/201299256-77e7899a-9842-48cd-9ecc-6e39e09bc15d.png" alt="image" /></p>

<ul>
  <li>I/O를 수행하는 special instruction에 의한 것 (좌)</li>
  <li>Memory Mapped I/O에 의한 것 (우)</li>
</ul>

<p><br /></p>

<h3 id="저장장치-계층-구조">저장장치 계층 구조</h3>

<p><img src="https://user-images.githubusercontent.com/71377968/201299307-225e2f42-6745-4031-9ed2-226562733dea.png" alt="image" /></p>

<ul>
  <li>휘발성 매체는 전원이 나가면 데이터가 사라짐</li>
  <li>비휘발성 매체는 전원이 나가도 데이터는 사라지지 않음</li>
  <li>Primary: CPU가 직접 접근할 수 있는 것(byte 단위로 접근이 가능해야 함 → DRAM)</li>
  <li>Secondary: CPU가 직접 접근할 수 없는 것(sector 단위로 접근 가능함)</li>
</ul>

<p><br /></p>

<p><strong>Caching</strong></p>

<ul>
  <li>CPU와 메인 메모리의 속도 차이를 완충하기 위해 캐시 메모리를 둠</li>
  <li>용량이 작아 모든 걸 담아 둘 수는 없음</li>
  <li>캐싱은 재사용을 목적으로 함 → 두 번째 요청부터 이미 읽어온 데이터를 사용</li>
</ul>

<p><br /></p>

<h3 id="프로그램의-실행메모리-load">프로그램의 실행(메모리 load)</h3>

<p><img src="https://user-images.githubusercontent.com/71377968/201299357-8242c3b8-9369-4190-b89b-fbc391b9c4d9.png" alt="image" /></p>

<p>프로그램은 file system에 실행 파일 형태로 저장되어있는데, 이를 실행하면 메모리에 올라감 (그 중간에 virtual memory를 거침 → virtual memory는 프로그램만의 독자적인 메모리 주소 공간에 형성된 단계로, code, data, stack으로 구성) 이때, 물리적 메모리에 모든걸 다 올리게 되면 메모리를 낭비하게 되므로 필요한 부분만 physical memory에 올리게 됨(사용이 끝나면 physical memory에서 쫓아냄 → disk의 Swap area)</p>

<ul>
  <li>code: CPU에서 실행할 기계어 코드 저장</li>
  <li>data: 변수 저장</li>
  <li>stack: 함수를 호출하거나 리턴할 때 데이터를 쌓아뒀다가 꺼냄</li>
</ul>

<p>*Swap area와 File system은 디스크지만 다른 용도로 사용됨. File system은 전원이 나가도 저장되어 있어야 하지만, Swap area는 전원이 나가면 의미 없는 데이터이므로, 메모리 연장 공간의 용도로 사용됨.</p>

<p><br /></p>

<h3 id="커널-주소-공간의-내용">커널 주소 공간의 내용</h3>

<p><img src="https://user-images.githubusercontent.com/71377968/201299403-ee6707b9-95dd-425f-bf39-57562fde4a55.png" alt="image" /></p>

<ul>
  <li>code: 인터럽트에서 무슨 일을 처리해야하는지를 저장함</li>
  <li>data: 운영체제가 사용하는 자료구조
    <ul>
      <li>PCB(Process Control Block): 프로세스를 관리하는 자료구조로, 프로세스마다 하나씩 존재함</li>
    </ul>
  </li>
  <li>stack: 함수를 호출하거나 리턴할 때 stack 영역을 이용하는데, 어떤 프로세스가 커널의 코드를 실행 중인가에 따라 프로세스마다 커널 스택을 따로 가짐</li>
</ul>

<p><br /></p>

<h3 id="함수">함수</h3>

<ul>
  <li>사용자 정의 함수: 자신의 프로그램에서 정의한 함수</li>
  <li>라이브러리 함수
    <ul>
      <li>자신의 프로그램에서 정의하지 않고 갖다 쓴 함수</li>
      <li>자신의 프로그램의 실행 파일에 포함됨</li>
    </ul>
  </li>
  <li>커널 함수
    <ul>
      <li>운영체제 프로그램의 함수</li>
      <li>커널 함수의 호출 = 시스템 콜
        <ul>
          <li>주소 점프를 할 수 없어 인터럽트 라인 세팅을 통해 CPU에 제어권을 넘겨야 함</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>*사용자 정의 함수와 라이브러리 함수는 프로세스의 주소 공간에 있고, 커널 함수는 커널 주소 공간에 있음</p>

<p><br /></p>

<h3 id="프로그램의-실행">프로그램의 실행</h3>

<p><img src="https://user-images.githubusercontent.com/71377968/201299463-b22e69e8-7400-4783-90b1-e32870c1f633.png" alt="image" /></p>

<ul>
  <li>user mode: 프로그램이 직접 CPU를 잡고 있음</li>
  <li>kernel mode: 시스템 콜 시 커널 모드로 넘어감</li>
</ul>

<p><br /></p>

<p><br /></p>

<p>[사진 출처] <a href="https://hyojaedev.tistory.com/29">https://hyojaedev.tistory.com/29</a></p>]]></content><author><name>kji-dec</name></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[반효경 교수님의 2014-1 운영체제 강의를 듣고 정리한 글입니다.]]></summary></entry><entry><title type="html">1-1. 강의소개</title><link href="/jekyll-theme-yat/os/2022/11/06/OS-Study-Week1-1.html" rel="alternate" type="text/html" title="1-1. 강의소개" /><published>2022-11-06T00:00:00+00:00</published><updated>2022-11-06T00:00:00+00:00</updated><id>/jekyll-theme-yat/os/2022/11/06/OS%20Study%20Week1-1</id><content type="html" xml:base="/jekyll-theme-yat/os/2022/11/06/OS-Study-Week1-1.html"><![CDATA[<p>반효경 교수님의 <a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">2014-1 운영체제 강의</a>를 듣고 정리한 글입니다.</p>

<h3 id="운영체제">운영체제</h3>

<p>: 컴퓨터 하드웨어 바로 위에 설치되는 소프트웨어 (OS가 있기에 사용자가 컴퓨터 하드웨어를 이용할 수 있음)</p>

<p>: 기능 및 목표</p>

<ul>
  <li>하드웨어와 어떻게 인터페이스 해야하는가 (컴퓨터 시스템의 자원을 효율적으로 관리)
    <ul>
      <li>프로세서, 기억장치, 입출력 장치 등의 효율적 관리 (+ 형평성도 요구됨)</li>
    </ul>
  </li>
  <li>각종 소프트웨어 혹은 사용자와 어떻게 인터렉션하며 기능해야하는가 (컴퓨터 시스템을 편리하게 사용할 수 있는 환경 제공)
    <ul>
      <li>동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상 제공</li>
      <li>하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행해줌</li>
    </ul>
  </li>
</ul>]]></content><author><name>kji-dec</name></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[반효경 교수님의 2014-1 운영체제 강의를 듣고 정리한 글입니다.]]></summary></entry><entry><title type="html">1-2. Introduction to Operating Systems</title><link href="/jekyll-theme-yat/os/2022/11/06/OS-Study-Week1-2.html" rel="alternate" type="text/html" title="1-2. Introduction to Operating Systems" /><published>2022-11-06T00:00:00+00:00</published><updated>2022-11-06T00:00:00+00:00</updated><id>/jekyll-theme-yat/os/2022/11/06/OS%20Study%20Week1-2</id><content type="html" xml:base="/jekyll-theme-yat/os/2022/11/06/OS-Study-Week1-2.html"><![CDATA[<p>반효경 교수님의 <a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">2014-1 운영체제 강의</a>를 듣고 정리한 글입니다.</p>

<p><br /></p>

<h3 id="운영체제">운영체제</h3>

<p>좁은 의미의 운영체제[<strong>커널</strong>]:  운영체제의 핵심적인 부분. 컴퓨터의 전원을 켜고 부팅이 된 이후에 항상 메모리에 상주함 (전공자의 입장에서 운영체제는 이 부분!)</p>

<p>넓은 의미의 운영체제: 커널을 포함하며, 각종 주변 시스템을 다루는 유틸리티를 포함 (ex: 윈도우)</p>

<p><br /></p>

<h3 id="운영체제의-목적">운영체제의 목적</h3>

<p>컴퓨터 시스템의 <strong>자원을 효율적으로 관리</strong></p>

<ul>
  <li>자원: CPU, 메모리, 각종 입출력 장치 등의 하드웨어 자원 &amp; 프로세스, 파일 메시지 등의 소프트웨어 자원</li>
  <li>이미 주어진 자원으로 최대한의 성능을 뽑아내는 것이 목적 → 자원을 <strong>효율적</strong> + 형평적으로 분배함</li>
  <li>사용자 및 운영체제 자신을 보호해야 함</li>
</ul>

<p><br /></p>

<p>컴퓨터 시스템을 편리하게 사용할 수 있게 함</p>

<ul>
  <li>여러 프로그램이 하나의 컴퓨터에서 실행될 때, 자신의 프로그램만이 해당 컴퓨터에서 실행되는 것과 같은 느낌을 주는 것이 운영체제의 목적</li>
  <li>ex) 실제로는 여러 프로그램이 CPU를 빠른 시간 내에 나눠서 사용하는 것이지만 사용자가 보기에 한 프로그램만이 온전히 실행되고 있다고 느낄 수 있음</li>
</ul>

<p><br /></p>

<h3 id="운영체제의-분류">운영체제의 분류</h3>

<p>동시 작업 가능 여부에 따라</p>

<ul>
  <li>단일 작업(주로 과거의 OS) - 한 번에 하나의 작업만 처리 (ex: MS-DOS)</li>
  <li>다중 작업(최근의 OS) - 동시에 두 개 이상의 작업 처리 (ex: UNIX, MS Windows)</li>
</ul>

<p><br /></p>

<p>지원해주는 사용자의 수에 따라</p>

<ul>
  <li>단일 사용자 (ex: MS-DOS, MS Windows)</li>
  <li>다중 사용자 (ex: UNIX, NT server)</li>
</ul>

<p><br /></p>

<p>처리 방식에 따라</p>

<ul>
  <li>일괄 처리(batch processing) - 어떤 작업이 주어져있을 때 바로바로 처리하는 것이 아니라, 작업을 모아서 한꺼번에 처리함 (현대 OS에서는 해당 처리 방식을 찾아보기 어려움) → interactive하지 않음</li>
  <li><strong>시분할(time sharing)</strong> - 여러 작업이 실행 될 때, 프로그램은 동시에 실행되는 것처럼 보이지만 운영체제가 작은 시간 단위로 나누어서 프로그램마다 시간을 할당함 (현대의 OS에서 사용하는 방식) → interactive한 방식, 일괄 처리 시스템에 비해 짧은 응답 시간 <em>BUT</em>, 시간의 제약조건이 없어서 사용자가 폭발적으로 증가하면 응답 시간이 늦어질 수 있음</li>
  <li>실시간(realtime OS) - 정해진 시간 안에 어떤 일이 반드시 종료됨을 보장함 (정확한 시간을 맞춰야 하는 정교한 장비에 주로 사용)
    <ul>
      <li>특수 시스템에 사용됨: 원자로 및 공장 제어, 미사일 제어, 반도체 장비, 로보트 제어 등</li>
      <li>확장: Hard realtime system(시간 제약이 치명적임 - ex: 미사일 제어), Soft realtime system(시간 제약이 비교적 덜 치명적임 - ex: 영화)</li>
    </ul>
  </li>
</ul>

<p>*범용 운영체제(시분할)에서 요구되는 실시간성에 대한 처리도 필요함 (ex: 스마트폰으로 영화를 보거나 내비게이션을 이용하는 것)</p>

<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Multitasking: 여러 작업이 동시에 시행되는 것
Multiprogramming: 여러 프로그램이 메모리에 동시에 올라가있는 것 (multitasking이 되려면 multiprogramming을 당연히 만족해야함)
Time sharing: CPU를 강조한 것
Multiprocess: 여러 프로그램이 동시에 실행됨
→ 유사한 용어

*Multiprocesser:  하나의 컴퓨터에 여러 CPU가 붙어있는 것(하드웨어적으로 다름)
</code></pre></div></div>

<p><br /></p>

<h3 id="운영체제의-예">운영체제의 예</h3>

<p>유닉스(UNIX) 계열</p>

<ul>
  <li>유닉스는 대형 컴퓨터를 위해 만들어진 운영체제</li>
  <li>Multitasking이 되고 여러 사용자를 동시에 지원해줌</li>
  <li>C언어로 대부분 작성됨</li>
  <li>초창기에는 소스코드가 공개됨 → 학습하기에도 좋음</li>
  <li>높은 이식성 → 다른 컴퓨터에 이식하기가 쉬움</li>
  <li>커널의 크기가 작음</li>
  <li>확장성이 좋음</li>
  <li>초창기에는 무료로 공개되었었음</li>
  <li>다양한 버전: System V, FreeBSD, SunOS, Solaris, Linux(→ 리눅스는 공개 소프트웨어!, 개인 PC에도 사용하기 용이함, 안드로이드의 커널로도 사용됨)</li>
</ul>

<p><br /></p>

<p>DOS</p>

<ul>
  <li>개인용 컴퓨터 PC를 위해 만들어진 운영체제</li>
  <li>단일 사용자, 단일 작업용 운영체제로 출발함 (메모리 관리 능력의 한계 - 주 기억 장치 640KB)</li>
</ul>

<p>Windows로 발전</p>

<ul>
  <li>MS사의 다중 작업용 GUI 기반 운영 체제</li>
  <li>Plug and Play, 네트워크 환경 강화</li>
  <li>DOS용 응용 프로그램과 호환성 제공</li>
  <li>초창기에는 불안정성 존재. 현재는 많이 해소됨</li>
  <li>풍부한 지원 소프트웨어</li>
</ul>

<p>*스마트 디바이스를 위한 운영체제 iOS 등도 등장하면서 운영체제가 점점 여러가지 형태로 발전함</p>

<p><br /></p>

<h3 id="운영체제의-구조">운영체제의 구조</h3>

<p><img src="https://user-images.githubusercontent.com/71377968/200158656-3f24acb1-5fca-49f3-8e50-4db8fe591eac.png" alt="image" /></p>

<ul>
  <li>CPU를 누구한테 줄 것인가 - <strong>CPU 스케줄링</strong></li>
  <li>한정된 메모리를 어떻게 쪼개어 쓸 것인가 - <strong>메모리 관리</strong></li>
  <li>디스크에 파일을 어떻게 보관할 것인가 - <strong>파일 관리</strong></li>
  <li>각기 다른 입출력장치와 컴퓨터 간에 어떻게 정보를 주고 받게 할 것인가 - <strong>입출력 관리</strong></li>
  <li>프로그램들을 어떻게 관리하고, 자원 할당 및 반환은 어떻게 할 것이며, 프로세스의 생성과 삭제, 그리고 프로세스 간 협력은 어떻게 할 것인가 - <strong>프로세스 관리</strong></li>
  <li>그 외) 보호 시스템, 네트워킹, 명령어해석기(command line interpreter)</li>
</ul>

<p>*CPU 스케줄링과 디스크 스케줄링은 다른 측면이 있음 (CPU의 경우 너무 빠르기 때문에 이것을 어떻게 관리해야 하나, 디스크의 경우 헤드의 움직임을 적게 하면서 많은 요청을 빨리 처리할 수 있는가)</p>

<p>*I/O 디바이스는 CPU에 비해 매우 느림 (인터럽트 사용)</p>]]></content><author><name>kji-dec</name></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[반효경 교수님의 2014-1 운영체제 강의를 듣고 정리한 글입니다.]]></summary></entry></feed>